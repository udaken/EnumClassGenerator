using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EnumClassGenerator;

record EnumClassAttributeInfo(
    ITypeSymbol TypeSymbol,
    IList<string> Names,
    IList<object>? Values,
    string TypeOfValue
    );

[Generator(LanguageNames.CSharp)]
public class SourceGenerator : IIncrementalGenerator
{
    const string attributeName = "EnumClassGenerator.GenerateEnumClassAttribute";
    const string attributeSource = // language=csharp
@"// <auto-generated />
#nullable enable
using System;
namespace EnumClassGenerator
{
    [System.Diagnostics.Conditional(""COMPILE_TIME_ONLY"")]
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    sealed class GenerateEnumClassAttribute : Attribute
    {
        public GenerateEnumClassAttribute(params string[] names) { Names = names; }

        public string[] Names { set; get; }
        public object[]? Values { set; get; }
        public Type TypeOfValue { set; get; } = typeof(int);
    }
}
";
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(c =>
        {
            c.AddSource("GenerateEnumClassAttribute.g.cs", Microsoft.CodeAnalysis.Text.SourceText.From(attributeSource, Encoding.UTF8));
        });
        var provider =
            context.SyntaxProvider.CreateSyntaxProvider(
                predicate, 
                transform).Where(p => p is not null).Collect();

        context.RegisterImplementationSourceOutput(provider, Emit);


        static bool predicate(SyntaxNode syntaxNode, System.Threading.CancellationToken ct)
            => syntaxNode is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

        static EnumClassAttributeInfo? transform(GeneratorSyntaxContext generatorSyntaxContext, System.Threading.CancellationToken ct)
        {
            var semanticModel = generatorSyntaxContext.SemanticModel;
            var cds = (ClassDeclarationSyntax)generatorSyntaxContext.Node;

            if (semanticModel.GetDeclaredSymbol(cds, ct) is not { } typeSymbol)
                return null;

            return GetAttribute(typeSymbol);
        }


        static EnumClassAttributeInfo? GetAttribute(ITypeSymbol typeSymbol)
        {
            var attr = typeSymbol.GetAttributes().SingleOrDefault(a => a.AttributeClass?.ToDisplayString() is attributeName);

            if (attr == null)
                return null;

            var args = attr.ConstructorArguments;
            if (args.Length == 0)
                return null;

            var names = args[0].Values.Select(c => (string)c.Value!).ToList();
            //var names = new[] { "D", "E" };
            var Values = attr.NamedArguments.GetValue("Values") is { Kind: TypedConstantKind.Array } tc ? tc.Values.Select(v => v.Value!).ToList() : new List<object>();
            string TypeOfValue = attr.NamedArguments.GetValue("TypeOfValue").ToCSharpString();

            return new(typeSymbol, names, Values, TypeOfValue);
        }
    }

    static void Emit(SourceProductionContext sourceProductionContext, ImmutableArray<EnumClassAttributeInfo?> attrList)
    {
        foreach (var attr in attrList)
        {
            if (attr is null) continue;

            var ns = attr.TypeSymbol.ContainingNamespace;
            var typename = attr.TypeSymbol.Name;
            var s = new StringBuilder()
                .AppendLine("#nullable enable")
                .AppendLine(ns.IsGlobalNamespace ? "" : "namespace " + ns.Name + "{")
                .AppendLine("using System;")
                .AppendLine("using System.Linq;")
                .AppendLine("using System.Collections.Generic;")
                .AppendLine("[Serializable]")
                .AppendLine($"abstract partial class {typename} : IEquatable<{typename}>, IComparable<{typename}> {{")
                .AppendLine("  public abstract int Ordinal { get; }")
                .AppendLine("  public string Name => _Names[Ordinal];")
                .AppendLine($"  private {typename}(){{}}")

                .AppendLine($"  public abstract bool Equals({typename}? obj);")
                .AppendLine($"  public override sealed bool Equals(object? obj) => obj is {typename} other && Equals(other);")
                .AppendLine($"  public override sealed int GetHashCode() => {typename.GetHashCode()} ^ Ordinal.GetHashCode();")
                .AppendLine($"  public override string ToString() => $\"{{nameof({typename})}}.{{Name}}\";")

                .AppendLine($"  public int CompareTo({typename}? other) => other?.Ordinal.CompareTo(Ordinal) ?? -1;")
                .AppendLine($"  public static bool operator ==({typename}? left,  {typename}? right) =>")
                .AppendLine($"    Object.ReferenceEquals(left, right) || (!Object.ReferenceEquals(left, null) && left.Equals(right));")
                .AppendLine($"  public static bool operator !=({typename}? left,  {typename}? right) => !(left == right);")

                .AppendLine($"  public static bool TryParse(ReadOnlySpan<char> name, out {typename}? value) {{ for (var i = 0; i < _Names.Length; i++) {{ if (name.SequenceEqual(_Names[i])) {{ value = _Values[i]; return true; }} }}  value = null ;return false; }}")

                .AppendLine($"  private static readonly {typename}[] _Values = {{{string.Join(", ", attr.Names.Select(i => $"{i}.Instance"))}}};")
                .AppendLine($"  public static ReadOnlySpan<{typename}> ValueSpan => _Values;")
                .AppendLine($"  public static IEnumerable<{typename}> Values => new System.Collections.ObjectModel.ReadOnlyCollection<{typename}>(_Values);")
                .AppendLine($"  private static readonly string[] _Names = {{{string.Join(", ", attr.Names.Select(i => $"\"{i}\""))}}};")
                .AppendLine($"  public static ReadOnlySpan<string> NamesSpan => _Names;")
                .AppendLine($"  public static IEnumerable<string> Names => new System.Collections.ObjectModel.ReadOnlyCollection<string>(_Names);")
                .AppendMembers(attr)
                .AppendLine("}")
                .AppendLine(ns.IsGlobalNamespace ? "" : "}")
                .ToString();

            sourceProductionContext.AddSource($"{ns.Name}_{attr.TypeSymbol.Name}.g.cs", s);
        }
    }
}

static class Ext
{
    public static StringBuilder AppendMembers(this StringBuilder source, EnumClassAttributeInfo attr)
    {
        var typename = attr.TypeSymbol.Name;
        if (attr.Values == null || attr.Values.Count > 0 && attr.Values.Count != attr.Names.Count)
            throw new Exception($"Values.Length must equals to Names.Length({attr.Values?.Count},{attr.Names.Count})");
        bool hasValue = attr.Values.Count == attr.Names.Count;

        if (hasValue)
            source.AppendLine($"  public abstract {attr.TypeOfValue} Value {{ get; }}");

        var ordinal = 0;
        foreach (var name in attr.Names)
        {
            var className = name;
            source
                .AppendLine($"public sealed partial class {className} : {typename} {{")
                .AppendLine($"  public static {typename} Instance {{get;}} = new {className}();")
                .AppendLine($"  private {className}() : base() {{}}")
                .AppendLine($"  public override int Ordinal => {ordinal};")
                .AppendLine(hasValue ? $"  public override {attr.TypeOfValue} Value => {attr.Values[ordinal]};" : "")
                .AppendLine($"  public override bool Equals({typename}? obj) => obj is {className};")
                .AppendLine("}");
            ordinal++;
        }
        return source;
    }

    public static TypedConstant GetValue(this ImmutableArray<KeyValuePair<string, TypedConstant>> source, string key)
    {
        return source.SingleOrDefault(pair => pair.Key == key).Value;
    }
}
